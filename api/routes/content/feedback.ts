import express, { type Request, type Response } from 'express';
import OpenAI from 'openai';
import getSupabaseClient from '../../supabaseClient.js';

const router = express.Router();

const supabase = getSupabaseClient();

const getOpenAIClient = () => {
  return new OpenAI({
    apiKey: process.env.OPENAI_API_KEY || 'sk-mock-key-for-testing'
  });
};

// POST /api/content/:id/feedback
// Analyze difference between original and final content
router.post('/:id/feedback', async (req: Request, res: Response): Promise<void> => {
  try {
    const openai = getOpenAIClient();
    const { id } = req.params;
    const { final_content } = req.body;

    if (!final_content) {
      res.status(400).json({ error: 'Final content is required' });
      return;
    }

    // 1. Get original content
    const { data: content, error } = await supabase
      .from('work_tasks')
      .select('original_content')
      .eq('id', id)
      .single();

    if (error || !content) {
      res.status(404).json({ error: 'Content not found' });
      return;
    }

    const original_content = content.original_content;

    if (!original_content) {
        // No original content to compare (maybe created before migration)
        res.json({ success: true, message: 'No original content to compare' });
        return;
    }

    // 2. If content is identical, no feedback needed
    if (original_content === final_content) {
        res.json({ success: true, message: 'No changes detected' });
        return;
    }

    // 3. Analyze differences using AI
    const analysisPrompt = `
You are an AI Feedback Analyzer. 
Compare the "Original Text" (generated by AI) and "Final Text" (edited by human).
Identify specific words or short phrases that were REMOVED by the human because they were likely disliked, clichÃ©d, or inappropriate.
Identify specific words added by the human that indicate preferred style.

Original Text: "${original_content}"
Final Text: "${final_content}"

Output JSON only:
{
  "deleted_terms": ["term1", "term2"], // Words removed (negative feedback)
  "added_terms": ["term3", "term4"]   // Words added (positive feedback)
}
Only include significant keywords, adjectives, or phrases. Ignore minor punctuation or grammar fixes.
`;

    const completion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [{ role: 'user', content: analysisPrompt }],
        response_format: { type: "json_object" }
    });

    const result = JSON.parse(completion.choices[0].message.content || '{}');
    const { deleted_terms, added_terms } = result;

    // 4. Update stats
    if (deleted_terms && deleted_terms.length > 0) {
        for (const word of deleted_terms) {
            // Upsert deletion count
            const { data: existing } = await supabase.from('ai_learning_stats').select('*').eq('word', word).single();
            
            if (existing) {
                await supabase.from('ai_learning_stats').update({ 
                    deleted_count: existing.deleted_count + 1,
                    last_updated: new Date().toISOString()
                }).eq('word', word);
            } else {
                await supabase.from('ai_learning_stats').insert({ 
                    word, 
                    deleted_count: 1 
                });
            }
        }
    }

    if (added_terms && added_terms.length > 0) {
        for (const word of added_terms) {
             const { data: existing } = await supabase.from('ai_learning_stats').select('*').eq('word', word).single();
            
            if (existing) {
                await supabase.from('ai_learning_stats').update({ 
                    added_count: existing.added_count + 1,
                    last_updated: new Date().toISOString()
                }).eq('word', word);
            } else {
                await supabase.from('ai_learning_stats').insert({ 
                    word, 
                    added_count: 1 
                });
            }
        }
    }

    // 5. Update content record with final text (work_tasks)
    await supabase.from('work_tasks').update({ content_text: final_content }).eq('id', id);

    res.json({ success: true, analysis: result });

  } catch (error: any) {
    console.error('Feedback Error:', error);
    res.status(500).json({ error: error.message });
  }
});

export default router;
